{"name":"conceptual-architecture-for-firebird","tagline":"In this paper, we investigate the conceptual architecture for the Firebird database. We identify the major components of the database system and their interactions. Some of these components themselves have their own architectures, which we will also discuss. We present some scenarios which illustrate the interactions between the components. We show that the top-level architecture is styled after a pipe and filter architecture, while each component may have its own architectural style.","body":"## Conceptual Architecture for Firebird\r\n\r\nHubert Chan and Dmytro Yashkir\r\n\r\nFaculty of Mathematical, Statistical and Computer Sciences\r\n\r\nUniversity of Waterloo, Canada.\r\n\r\nJanuary 29, 2002\r\n\r\nUpdated by : Popa Adrian Marius\r\n\r\nMay 16, 2014\r\n\r\n#### Abstract\r\n\r\nIn this paper, we investigate the conceptual architecture for the Firebird\r\ndatabase. We identify the major components of the database system and their\r\ninteractions. Some of these components themselves have their own\r\narchitectures, which we will also discuss. We present some scenarios which\r\nillustrate the interactions between the components. We show that the top-level\r\narchitecture is styled after a pipe and filter architecture, while each\r\ncomponent may have its own architectural style.\r\n\r\n**Table of Contents**\r\n\r\nConceptual Architecture for Firebird 2.5\r\n\r\n  * Introduction \r\n  * Top-level architecture \r\n  * Remote communication \r\n  * SQL translator \r\n  * JRD \r\n  * JRD and Lock module \r\n  * Use scenarios \r\n  * Extensibility of Firebird \r\n  * Conclusion \r\n\r\n#### Introduction\r\n\r\nSoftware architecture presents developers with a tool for organizing large,\r\ncomplex software systems into various components, allowing the developers to\r\nbetter understand the system as a whole by reducing the number of components\r\nwhich must be kept in mind. It allows each developer to focus on a smaller\r\npart of the system, and enables the development team to integrate its work\r\ntogether by specifying the interfaces between the various parts in a clear and\r\nwell defined manner.\r\n\r\nThere are several different types of architectural views. The conceptual\r\narchitecture is a high-level view, with relatively few details, and is\r\nparticularly well suited for describing the functionality of a system.\r\n\r\nIn this paper, we investigate the conceptual architecture for the Firebird\r\ndatabase.\r\n\r\nFirebird includes many tools and utilities for developing and administering a\r\ndatabase, and the code base includes code from older versions, as well as some\r\nexperimental branches (Firebird devel branch:\r\n[trunk](http://sourceforge.net/p/firebird/code/HEAD/tree/firebird/trunk/) ).\r\nWe will not be considering these in our analysis.\r\n\r\nWe begin by discussing the overall architecture of the system. We then look at\r\nthe architectures of some of the subsystems, and we finally present scenarios\r\nwhich illustrate the behaviour of the system in response to queries generated\r\nby clients.\r\n\r\n#### Top-level architecture\r\n\r\nFirebird can be divided into four major components (see Figure 1): the remote\r\nconnection system, the SQL translator, the relational database engine, and the\r\nlock manager. The arrows in the diagram indicate the flow of data. We include\r\nthe clients in the diagram to illustrate their relationship with the rest of\r\nthe system.\r\n\r\n![](http://www.ibphoenix.com/images/doc_25_1.gif)\r\n\r\n_Figure 1: Top-level architecture_\r\n\r\n**remote connection system [(REMOTE)](http://sourceforge.net/p/firebird/code/HEAD/tree/firebird/branches/B2_5_Release/src/remote/):** This subsystem allows remote clients to connect to the database over different network protocols. It is composed of two parts: a client-side component and a server-side component. \r\n\r\n**SQL translator [(DSQL)](http://sourceforge.net/p/firebird/code/HEAD/tree/firebird/branches/B2_5_Release/src/dsql/):** This subsystem translates requests from SQL into BLR, the native language of the database.\r\n\r\n**relational database engine [(JRD)](http://sourceforge.net/p/firebird/code/HEAD/tree/firebird/branches/B2_5_Release/src/jrd/):** This subsystem performs the actual queries.\r\n\r\n**lock manager [(LOCK)](http://sourceforge.net/p/firebird/code/HEAD/tree/firebird/branches/B2_5_Release/src/lock/):** This subsystem handles synchronization among transactions.\r\n\r\nThe arrangement of the remote connection system, SQL translator, and\r\nrelational database engine, can be seen as a pipe and filter style of\r\narchitecture: a request flows through the remote connection system, to the SQL\r\ntranslator, where it is converted to BLR. The BLR goes through the relational\r\ndatabase, which returns a request through the remote connection system.\r\n\r\n#### Remote communication\r\n\r\nThe remote communication subsystem, REMOTE, allows clients to communicate\r\nremotely, or locally, with the server. It enables communication over several\r\ndifferent network protocols, such as TCP/IP, [XNET](http://sourceforge.net/p/f\r\nirebird/code/HEAD/tree/firebird/branches/B2_5_Release/doc/README.xnet)\r\n(replaced the former IPC/IPServer and is firebird implementation of the local\r\ntransport protocol) The subsystem is split roughly into two parts: a server\r\nside, and a client side. It contains generic code for client-server\r\ncommunication, as well as protocol-specific code.\r\n\r\nIt can be viewed as a layered system: conceptually, the client sends requests\r\nto the server, through a generic communication layer. The generic layers\r\ncommunicate through a protocol-specific layer, and the protocol-specific\r\nlayers communicate through the operating system's network stack. This is much\r\nlike to a two-layered version of the OSI reference network model.\r\n\r\n![](http://www.ibphoenix.com/images/doc_25_2.gif)\r\n\r\n_Figure 2: Remote connection_\r\n\r\nThe client can also communicate with the server locally, using a module which\r\nemulates a network connection by using shared memory.\r\n\r\n#### SQL translator\r\n\r\nThe SQL translator,>DSQL, converts SQL queries into the native BLR language.\r\nIts architecture is like that of a simplified compiler: it contains a lexer,\r\nparser, symbol table, and code generator.\r\n\r\n![](http://www.ibphoenix.com/images/doc_25_3.gif)\r\n\r\n_Figure 3: SQL translator_\r\n\r\nAs in all compilers, the lexer, parser, and code generator are arranged,\r\nconceptually, as a pipeline. The lexer divides the input into tokens, the\r\nparser determines the meaning of the input, based on the tokens, and the code\r\ngenerator emits BLR code which is equivalent to the original SQL.\r\n\r\n#### JRD\r\n\r\nThe JRD subsystem executes requests and returns their results. It handles the\r\naccess to the disk through a virtual IO system, verifies that security\r\nconstraints are followed, and ensures that transactions are handled\r\natomically.\r\n\r\nRequests first pass through a compiler, which translates from BLR into an\r\ninternal representation of the request. It calls the metadata subsystem, MET,\r\nto get metadata pertaining to the request, and to ensure that the requested\r\ntables are present.\r\n\r\n![](http://www.ibphoenix.com/images/doc_25_4.gif)\r\n\r\n_Figure 4: Relational database engine_\r\n\r\nThe Exec subsystem then processes the requests, using the B-tree subsystem for\r\nindexing, the security subsystem to check user priviledges, the transation\r\nsubsystem to ensure atomic execution of a series of requests, the sort\r\nsubsystem to sort, and the lock manager to ensure concurrency. It uses a\r\nvirtual IO system to access the disk, and it uses the metadata subsystem to\r\noperate on metadata.\r\n\r\nThe virtual IO subsystem is a layered system with three layers. The top layer\r\npresents an abstract method for accessing the data on the disk. The second\r\nlayer, the cache manager, handes caching of the data, to speed up data access.\r\nIt is the last layer which has a concept of structured data in the database.\r\nThe final layer is a physical IO layer which is specific to the operating\r\nsystem on which the engine is run, and makes the system calls to access the\r\ndisk.\r\n\r\n#### JRD and Lock module\r\n\r\nThe main purpose of the lock module is concurrency control, when multiple\r\nusers are accessing same database file simultaneously. Such situations are a\r\ncommon occurrence during the normal operation of any DBMS.\r\n\r\nLock handling is separated into two major parts: the lock handler sub-module\r\ninside the JRD and the Lock module that handles concurrent access to the lock\r\ntable. Figure 5 illustrates relationship between these parts.\r\n\r\n![](http://www.ibphoenix.com/images/doc_25_5.gif)\r\n\r\n_Figure 5: JRD and Lock module_\r\n\r\nRequests that need access to the lock mechanism are divided into two major\r\ncategories, metadata modification requests and usual data requests. Both of\r\nthese categories use lock the handler to be able to access the lock mechanism.\r\n\r\nNormally when modification is needed, a lock on the appropriate data is\r\nrequested. Then modification is performed and the lock is released. If it is\r\nimpossible to gain a lock, the lock handler can wait certain amount of time\r\nfor the other lock handler to release the lock and then resume normal\r\nexecution.\r\n\r\nThe Lock module itself waits for the requests from lock handlers. From their\r\nrequests it performs modifications to the lock table.\r\n\r\n#### Use scenarios\r\n\r\nThis section describes two common scenarios of the Firebird operation. These\r\nhelp better understanding of the DBMS architecture.\r\n\r\n##### Scenario 1: New table creation\r\n\r\nThis scenario describes the creation of a new table in the database. When\r\nreading through the following description, please refer to the appropriate\r\ndiagrams above.\r\n\r\n  1. Request originates from the user application, and is passed to Remote module client side\r\n  2. Requests is packaged depending on the network used and passed through the network to the Remote server side\r\n  3. DSQL is called to transform request from SQL to BLR\r\n  4. JRD is called, CMP is called to compile the request\r\n  5. Exec is called to execute the request, MET is called\r\n  6. Request begins execution in MET since it modifies metadata for the DB\r\n  7. Lock handler is called to obtain a lock on the metadata of the DB\r\n  8. Lock handler calls Lock, which adds appropriate lock to the lock table\r\n  9. MET calls virtual IO library to commit changes to the disk\r\n  10. Appropriate disk handling routine is called depending on the file system\r\n  11. MET calls Lock handler, which calls Lock to remove lock from the Lock table\r\n  12. JRD calls Remote module to return success message to the user program\r\n  13. Remote moves the message through the network and get it to the user application\r\n\r\n##### Scenario 2: Search for a row by index field\r\n\r\nThis scenario describes simple search request to the database.\r\n\r\n  1. Request is created in the user application and passed to the Remote client side\r\n  2. Remote moves request to the server side and calls DSQL\r\n  3. DSQL transform SQL of the request into BLR\r\n  4. JRD is called and CMP compiles the request\r\n  5. EXEC starts executing the request\r\n  6. Virtual IO is called to get appropriate table\r\n  7. Cache is checked for the data requested\r\n  8. Search routine in B-tree module is called to find row with appropriate index\r\n  9. Remote is called and returns result of the search to the user application\r\n\r\n#### Extensibility of Firebird\r\n\r\nA good test for any system architecture is how it can accommodate future\r\nchanges and expansions. Firebird existed under different names since 1985;\r\nobviously large number of changes and enhancements was implemented since then.\r\nHowever the basic conceptual architecture did not change.\r\n\r\nFirst, let's examine some changes made in the Remote module. With the\r\nappearance of a large number of new LAN standards, Remote was modified to\r\nallow it to work with them. Since all of the network communication routines\r\nare isolated in the remote module, these changes do not affect other parts of\r\nthe system. An example of such a modification is the addition of the IPSERVER\r\nmodule inside Remote. It was added to allow users to run Firebird on a single\r\nWindows-based machine where client and server share one machine. This\r\nmodification was relatively simple, even though there is no LAN involved\r\nwhatsoever in this implementation.\r\n\r\nA second example of modifications is the addition of the Windows file system\r\nto the Virtual IO module. To add the ability to run Firebird on a machine\r\nusing the Windows file system, the only modification required was to add\r\nanother subsystem in the IO system that enables operation with the Windows\r\nfile system.\r\n\r\n#### Conclusion\r\n\r\nIn this paper, we discuss the conceptual architecture for Firebird. The system\r\nis composed of four major compenents, arranged in a pipe and filter style. We\r\nalso look at the architecture within some of the subsystems. We provide\r\nscenarios illustrating the behaviour of the system in response to different\r\nclient requests and the interactions between the subsystems, and we\r\ndemonstrate how the architecture allows for extensions to the system, such as\r\nnew network protocols or file systems.\r\n\r\n##### References\r\n\r\n[Garlan, David ](http://www.cs.cmu.edu/~garlan/)and [Shaw,\r\nMary](http://www.cs.cmu.edu/afs/cs.cmu.edu/user/shaw/www/Shaw-home.html) ,\"\r\n[An Introduction to Software Architecture\"](http://web.archive.org/web/2001020\r\n8083910/http://www.cs.cmu.edu/afs/cs/project/able/www/paper_abstracts/intro_so\r\nftarch.html), _Advances in Software Engineering and Knowledge Engineering_,\r\nVolume 1, World Scientific Publishing Co., 1993.\r\n\r\nHarrison, Ann and Beach, Paul; \" [A Cut Out and Keep Guide to the Firebird\r\nSource Code](http://www.ibphoenix.com/resources/documents/search/doc_32)\";\r\nIBPhoenix; October 2001.\r\n\r\nHarrison, Ann; \" [High-level Description of the InterBase 6.0 Source Code](htt\r\np://web.archive.org/web/20020213052216/http://www.ibphoenix.com/ibp_source_ove\r\nrview.html)\"; IBPhoenix.\r\n\r\nKruchten, Phillipe B., [The 4+1 Views Model of\r\nArchitecture](http://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-\r\narchitecture.pdf), IEEE Software, Nov 95, pp 42-50.\r\n\r\n[Y-Valve\r\nArchitecture](http://www.ibphoenix.com/resources/documents/search/doc_119) ,\r\nFrom Jim Starkey on the Firebird Development List 13th December 2003.\r\n\r\n[ Vulcan\r\nArchitecture](http://www.ibphoenix.com/resources/documents/attic/doc_116) 30th\r\nApr 2004 Vulcan Development page.\r\n\r\n[ OSRI Architecture\r\n](http://www.ibphoenix.com/resources/documents/design/doc_33) The Philosophy,\r\nThe Model , The API ,Layering and Implementation Rules.\r\n\r\n[DDL execution architecture in Firebird - why we need to move\r\non](http://asfernandes.blogspot.ro/2009/08/ddl-execution-architecture-in-\r\nfirebird_4841.html)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}